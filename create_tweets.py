
# # import pandas as pd
# # import json




# # def top_5_selection(analyzed_tweets, engagement_type: str):
# #     df = pd.DataFrame(analyzed_tweets)
# #     filtered_df = df[df['engagement_type'] == engagement_type]
# #     return filtered_df.nlargest(5, columns=['engagement_score']).to_dict(orient="records")\

# from time import sleep
# import pandas as pd
# import json

# from run_prompt import execute_gemini_for_tweets, execute_gemini_for_tweet_pred

# def load_analyzed_tweets(file_path="analyzed_tweets.json"):
#     with open(file_path) as f:
#         data = json.load(f)

#     # If JSON is a dict, check if it has "tweets" key
#     if isinstance(data, dict):
#         if "tweets" in data:
#             analyzed_tweets = data["tweets"]
#         else:
#             raise ValueError("JSON file is a dict but does not contain 'tweets' key")
#     elif isinstance(data, list):
#         analyzed_tweets = data
#     else:
#         raise ValueError("Unexpected JSON structure in analyzed_tweets.json")

#     return analyzed_tweets

# def top_5_selection(analyzed_tweets, engagement_type: str):
#     df = pd.DataFrame(analyzed_tweets)
#     print("Columns detected:", df.columns.tolist())  # Debugging

#     # Safety checks
#     if "engagement_type" not in df.columns or "engagement_score" not in df.columns:
#         print("⚠️ Missing 'engagement_type' or 'engagement_score'. Returning first 5 rows instead.")
#         return df.head(5).to_dict(orient="records")

#     filtered_df = df[df["engagement_type"] == engagement_type]

#     if filtered_df.empty:
#         print(f"⚠️ No tweets found for engagement_type='{engagement_type}'. Returning top 5 overall.")
#         return df.nlargest(5, columns=["engagement_score"]).to_dict(orient="records")

#     return filtered_df.nlargest(5, columns=["engagement_score"]).to_dict(orient="records")


# def create_tweet(prompt):
#     with open("analyzed_tweets.json") as f:
#         data = json.load(f)
# #     prompt = """
# # Write a tweet for the newly releasing iPhone 17 Pro Max with A18 Pro SoC,
# # highlighting its physically moving camera zoom, targeting camera enthusiasts.
# #     """
#     engagement_type = "like"
#     top_5_tweets = top_5_selection(data, engagement_type)

#     # System prompt enforcing JSON format
#     system_prompt = f"""
# You are an AI tweet generator.

# Task: Write an engaging tweet for my tech company.
# PROMPT: {prompt}

# Here are example tweets and their sentiment analysis with very high user
# engagements of other similar companies:
# {top_5_tweets}

# Return ONLY valid JSON in this format:
# {{
#   "tweet": "<your tweet>",
#   "prediction": "<short prediction of engagement>",
#   "explanation": "<why this will perform well>"
# }}
# """

#     # Generate tweets with two different models
#     out_a = execute_gemini_for_tweets(prompt=system_prompt, model="gemini-2.5-flash-lite")
#     out_dict=json.loads(out_a)
#     tweet_a=out_dict['tweet']
#     print("TWEET_A====>")
#     print(tweet_a)
#     sleep(2)
#     out_b = execute_gemini_for_tweets(prompt=system_prompt, model="gemini-1.5-flash")
#     out_dict_b=json.loads(out_b)
#     tweet_b=out_dict_b['tweet']
#     print("TWEET_B=====>")
#     print(tweet_b)
#     sleep(2)

#     # tweet_a, tweet_b = None, None

#     # try:
#     #     out_dict = json.loads(out_a) if out_a else None
#     #     time.sleep(1.5)
#     #     out_dict1 = json.loads(out_b) if out_b else None
#     #     time.sleep(1.5)

#     #     if not out_dict or not out_dict1:
#     #         print("❌ Could not generate valid tweets.")
#     #         return

#     #     tweet_a = out_dict.get("tweet")
#     #     tweet_b = out_dict1.get("tweet")

#     #     print("TWEET_A ========>")
#     #     print(tweet_a)
#     #     print("TWEET_B ========>")
#     #     print(tweet_b)

#     # except Exception as e:
#     #     print("Error parsing gemini output (tweet creation):", e)
#     #     print("Raw Output A:", out_a)
#     #     print("Raw Output B:", out_b)
#     #     return  # stop here if tweets are invalid

#     # ---- Comparison step ----
#     # if tweet_a and tweet_b:
#     prompt_for_comparing = f"""
# You are given two tweets generated by different AI models. 
# Tweet A: {tweet_a}
# Tweet B: {tweet_b}

# Your task is to compare both tweets and decide which one is better overall 
# based on the following criteria and using this set of Best Performing Tweets {top_5_tweets}:

# Clarity – Is the tweet easy to understand?
# Engagement – Does it capture attention and encourage interaction?
# Creativity – Does it use interesting language, style, or ideas?
# Relevance – Is the content aligned with the given topic?
# For each tweet, provide a short evaluation mentioning strengths and weaknesses.

# Return ONLY valid JSON in this format:
# {{
#   "tweetA_vs_tweetB": "<evaluation>",
#   "prediction": "Tweet A or Tweet B",
#   "explanation": "<why>"
# }}
# """
#     prediction_result= execute_gemini_for_tweet_pred(prompt=prompt_for_comparing, model="gemini-2.5-flash")
#     sleep(1.5)
    
#     out_prediction=json.loads(prediction_result)
#     tweet_a_vs_tweet_b=out_prediction['tweetA_vs_tweetB']
#     prediction = out_prediction["prediction"]
#     explanation = out_prediction["explanation"]
    

#         # try:
#         #     out_dict2 = json.loads(prediction) if prediction else None
#         #     if not out_dict2:
#         #         print("❌ Comparison model did not return valid JSON.")
#         #         print("Raw Output:", prediction)
#         #         return

#         #     tweetA_vs_tweetB = out_dict2["tweetA_vs_tweetB"]
#         #     prediction_result = out_dict2["prediction"]
#         #     explanation = out_dict2["explanation"]

#     print("TWEET_A VS TWEET_B ========>")
#     print(tweet_a_vs_tweet_b)
#     print("Prediction =======>")
#     print(prediction)
#     print("Explanation =======>")
#     print(explanation)

#         # except Exception as e:
#         #     print("Error parsing gemini output (comparison):", e)
#         #     print("Raw Output", prediction)
            
#     return {
#     "tweet_a":tweet_a,
#     "tweet_b":tweet_b,
#     "tweet_a_vs_tweet_b": tweet_a_vs_tweet_b,
#     "prediction": prediction,
#     "explanation": explanation
# }


# # if __name__ == "__main__":
    

# #     # If data is a list of strings, convert each into a dict
# #     if isinstance(data[0], str):
# #         data = [json.loads(item) for item in data]

# #     print("tweets loaded ✅", len(data))
# #     create_tweet(data)



import sys
from time import sleep
import pandas as pd
import json

from run_prompt import execute_gemini_for_tweets, execute_gemini_for_tweet_pred


# ----------------------------
# Load analyzed tweets safely
# ----------------------------
def load_analyzed_tweets(file_path="analyzed_tweets.json"):
    with open(file_path) as f:
        data = json.load(f)

    if isinstance(data, dict):
        if "tweets" in data:
            analyzed_tweets = data["tweets"]
        else:
            raise ValueError("JSON file is a dict but does not contain 'tweets' key")
    elif isinstance(data, list):
        analyzed_tweets = data
    else:
        raise ValueError("Unexpected JSON structure in analyzed_tweets.json")

    return analyzed_tweets


# ----------------------------
# Select Top 5 tweets - for efficiency, avoid inconsistencies and sustainable for large data
# ----------------------------
def top_5_selection(analyzed_tweets, engagement_type: str):
    df = pd.DataFrame(analyzed_tweets)
    print("Columns detected:", df.columns.tolist())  # Debugging

    if "engagement_type" not in df.columns or "engagement_score" not in df.columns:
        print("⚠️ Missing 'engagement_type' or 'engagement_score'. Returning first 5 rows instead.")
        return df.head(5).to_dict(orient="records")

    filtered_df = df[df["engagement_type"] == engagement_type]

    if filtered_df.empty:
        print(f"⚠️ No tweets found for engagement_type='{engagement_type}'. Returning top 5 overall.")
        return df.nlargest(5, columns=["engagement_score"]).to_dict(orient="records")

    return filtered_df.nlargest(5, columns=["engagement_score"]).to_dict(orient="records")


# ----------------------------
# Create Tweet Function
# ----------------------------
def create_tweet(prompt):
    try:
        data = load_analyzed_tweets("analyzed_tweets.json")
    except Exception as e:
        print("❌ Error loading analyzed_tweets.json:", e)
        return {"error": "Failed to load analyzed_tweets.json"}

    engagement_type = "like"
    top_5_tweets = top_5_selection(data, engagement_type)
    # print(data)

    system_prompt = f"""
You are an AI tweet generator.

Task: Write an engaging tweet for my tech company.
PROMPT: {prompt}

Here are example tweets and their sentiment analysis with very high user
engagements of other similar companies:
{top_5_tweets}

Return ONLY valid JSON in this format:
{{
  "tweet": "<your tweet>",
  "prediction": "<short prediction of engagement>",
  "explanation": "<why this will perform well>"
}}
"""

    # ---- Model A ----
    out_a = execute_gemini_for_tweets(prompt=system_prompt, model="gemini-2.5-flash-lite") #niche llm
    try:
        out_dict = json.loads(out_a)
        tweet_a = out_dict.get("tweet", "❌ No tweet returned")
    except Exception as e:
        print("Error parsing Gemini A:", e, "Raw:", out_a)
        tweet_a = "❌ Failed"

    print("TWEET_A====>")
    print(tweet_a)
    sleep(2)

    # ---- Model B ----
    out_b = execute_gemini_for_tweets(prompt=system_prompt, model="gemini-2.5-flash")
    try:
        out_dict_b = json.loads(out_b)
        tweet_b = out_dict_b.get("tweet", "❌ No tweet returned")
    except Exception as e:
        print("Error parsing Gemini B:", e, "Raw:", out_b)
        tweet_b = "❌ Failed"

    print("TWEET_B====>")
    print(tweet_b)
    sleep(2)

    # ---- Comparison ----
    prompt_for_comparing = f"""
You are given two tweets generated by different AI models. 
Tweet A: {tweet_a}
Tweet B: {tweet_b}

Your task is to compare both tweets and decide which one is better overall 
based on the following criteria and using this set of Best Performing Tweets {top_5_tweets}:

Clarity – Is the tweet easy to understand?
Engagement – Does it capture attention and encourage interaction?
Creativity – Does it use interesting language, style, or ideas?
Relevance – Is the content aligned with the given topic?
For each tweet, provide a short evaluation mentioning strengths and weaknesses.

Return ONLY valid JSON in this format:
{{
  "tweetA_vs_tweetB": "<evaluation>",
  "prediction": "Tweet A or Tweet B",
  "explanation": "<why>"
}}
"""
    prediction_result = execute_gemini_for_tweet_pred(prompt=prompt_for_comparing, model="gemini-2.5-flash")

    try:
        out_prediction = json.loads(prediction_result)
        tweet_a_vs_tweet_b = out_prediction.get("tweetA_vs_tweetB", "❌ No comparison")
        prediction = out_prediction.get("prediction", "❌ No prediction")
        explanation = out_prediction.get("explanation", "❌ No explanation")
    except Exception as e:
        print("Error parsing comparison:", e, "Raw:", prediction_result)
        tweet_a_vs_tweet_b = "❌ Failed"
        prediction = "❌ Failed"
        explanation = "❌ Failed"

    print("TWEET_A VS TWEET_B ========>")
    print(tweet_a_vs_tweet_b)
    print("Prediction =======>")
    print(prediction)
    print("Explanation =======>")
    print(explanation)

    return {
        "tweet_a": tweet_a,
        "tweet_b": tweet_b,
        "tweet_a_vs_tweet_b": tweet_a_vs_tweet_b,
        "prediction": prediction,
        "explanation": explanation
    }

